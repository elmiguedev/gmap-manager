<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/Layer.js | babel_webpack_starter</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Starter pack for compiling ES6+ apps to ES5"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="babel_webpack_starter"><meta property="twitter:description" content="Starter pack for compiling ES6+ apps to ES5"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/GmapManager.js~GmapManager.html">GmapManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Layer.js~Layer.html">Layer</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/Layer.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">export default class Layer {
  // constructor
  // --------------------------
  constructor(map, id) {
    this.map = map;
    this.id = id;

    this.layers = [];
    this.markers = [];
    this.polygons = [];
    this.polylines = [];
  }

  // own methods
  // --------------------------
  clear() {
    this.clearMarkers();
    this.clearPolygons();
    this.clearLayers();
  }

  setVisible(visible) {
    this.setVisibleMarkers(visible);
    this.setVisiblePolygons(visible);
    this.setVisiblePolylines(visible);
    this.setVisibleLayers(visible);

    this.setVisibleHeatmap(visible);
  }

  // layers methods
  // --------------------------

  addLayer(id) {
    if (this.getLayer(id)) {
      throw new Error(&quot;layer alredy exists&quot;);
    }
    const layer = new Layer(this.map, id);
    this.layers.push(layer);
    return layer;
  }

  getLayer(id) {
    return this.layers.filter(x =&gt; x.id === id)[0];
  }

  removeLayer(id) {
    const index = this.layers.indexOf(this.getLayer(id));
    if (index) {
      return this.layers.splice(index, 1);
    }
  }

  setVisibleLayers(visible) {
    for (const layer of this.layers) {
      layer.setVisible(visible);
    }
  }

  clearLayers() {
    for (const layer of this.layers) {
      layers.clear();
    }
    this.layers = [];
  }

  // markers methods
  // --------------------------

  addMarker(id, options) {
    // error management
    if (id === Object(id)) {
      throw new Error(&quot;must set a marker id&quot;);
    }

    if (this.getMarker(id)) {
      throw new Error(&quot;marker id alredy exists&quot;);
    }

    // default properties
    options.map = this.map;
    options.id = id;
    const marker = new google.maps.Marker(options);

    // custom properties: events
    if (options[&quot;events&quot;] != null) {
      for (var name in options[&quot;events&quot;]) {
        google.maps.event.addListener(marker, name, options[&quot;events&quot;][name]);
      }
    }

    // custom properties: info window
    if (options[&quot;infoWindowContent&quot;] != null) {
      marker.infowindow = new google.maps.InfoWindow({
        content: options[&quot;infoWindowContent&quot;]
      });

      marker.addListener(&quot;click&quot;, function() {
        this.infowindow.open(this.getMap(), this);
      });
    }

    // add to array
    this.markers.push(marker);
    return marker;
  }

  getMarker(id) {
    return this.markers.filter(x =&gt; x.id === id)[0];
  }

  removeMarker(id) {
    const index = this.markers.indexOf(this.getMarker(id));
    if (index) {
      return this.markers.splice(index, 1);
    }
  }

  clearMarkers() {
    for (const marker of this.markers) {
      marker.setMap(null);
    }
    this.markers = [];
  }

  setVisibleMarkers(visible) {
    if (!this.heatmap)
      for (const marker of this.markers) {
        marker.setVisible(visible);
      }
  }

  createHeatmap(options) {
    // destroy current heatmap
    if (this.heatmap) {
      this.heatmap.setMap(null);
      this.heatmap = null;
    }

    // hide all markers
    this.setVisibleMarkers(false);

    // set default values
    options.data = this.markers.map(x =&gt; x.position);
    options.map = this.map;

    // creates new heatmap
    this.heatmap = new google.maps.visualization.HeatmapLayer(options);
  }

  setVisibleHeatmap(visible) {
    if (this.heatmap) {
      if (visible) this.heatmap.setMap(this.map);
      else this.heatmap.setMap(null);
    }
  }

  // polygons methods
  // --------------------------

  addPolygon(id, options) {
    // error management
    if (!id) {
      throw new Error(&quot;must set a polygon id&quot;);
    }

    if (this.getPolygon(id)) {
      throw new Error(&quot;polygon id alredy exists&quot;);
    }

    // default properties
    options.map = this.map;
    options.id = id;
    const polygon = new google.maps.Polygon(options);

    // custom properties: events
    if (options[&quot;events&quot;] != null) {
      for (var name in options[&quot;events&quot;]) {
        google.maps.event.addListener(polygon, name, options[&quot;events&quot;][name]);
      }
    }

    // add to array
    this.polygons.push(polygon);
    return polygon;
  }

  getPolygon(id) {
    return this.polygons.filter(x =&gt; x.id === id)[0];
  }

  removePolygon(id) {
    const index = this.polygons.indexOf(this.getPolygon(id));
    if (index) {
      return this.polygons.splice(index, 1);
    }
  }

  setVisiblePolygons(visible) {
    for (const polygon of this.polygons) {
      polygon.setVisible(visible);
    }
  }

  clearPolygons() {
    for (const polygon of this.polygons) {
      polygon.setMap(null);
    }
    this.polygons = [];
  }

  // polylines methods
  // --------------------------

  addPolyline(id, options) {
    // error management
    if (!id) {
      throw new Error(&quot;must set a polyline id&quot;);
    }

    if (this.getPolyline(id)) {
      throw new Error(&quot;polyline id alredy exists&quot;);
    }

    // default properties
    options.map = this.map;
    options.id = id;
    const polyline = new google.maps.Polyline(options);

    // custom properties: events
    if (options[&quot;events&quot;] != null) {
      for (var name in options[&quot;events&quot;]) {
        google.maps.event.addListener(polyline, name, options[&quot;events&quot;][name]);
      }
    }

    // add to array
    this.polylines.push(polyline);
    return polyline;
  }

  getPolyline(id) {
    return this.polylines.filter(x =&gt; x.id === id)[0];
  }

  removePolyline(id) {
    const index = this.polylines.indexOf(this.getPolyline(id));
    if (index) {
      return this.polylines.splice(index, 1);
    }
  }

  setVisiblePolylines(visible) {
    for (const polyline of this.polylines) {
      polyline.setVisible(visible);
    }
  }

  clearPolylines() {
    for (const polyline of this.polylines) {
      polyline.setMap(null);
    }
    this.polylines = [];
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
